(**************************************************************************)
(*  This is part of ATBR, it is distributed under the terms of the        *)
(*         GNU Lesser General Public License version 3                    *)
(*              (see file LICENSE for more details)                       *)
(*                                                                        *)
(*       Copyright 2009-2010: Thomas Braibant, Damien Pous.               *)
(**************************************************************************)

(** Properties, definitions, hints and tactics for semilattices :
   - [aci_reflexivity] solves the equational theory
   - [aci_normalize] normalizes the goal modulo associativity, commutativity, and idempotence
   - [ac_rewrite] does closed rewrites modulo associativity, commutativity
   *)

Require Import Common.
Require Import Classes.
Require Import Graph.
Require Import MyFSets Numbers.
Require        Reification. 

Set Implicit Arguments.
Unset Strict Implicit.
Unset Printing Implicit Defensive.

(** Hints  *)
Hint Extern 0 (leq _ _ _ _) => apply leq_refl.

Hint Extern 0 (equal _ _ _ _) => first [
    apply plus_assoc
  | apply plus_com
  | apply plus_idem
  | apply plus_neutral_left
]: algebra.
Hint Extern 2 (equal _ _ _ _) => first [
    apply plus_compat; instantiate
]: compat algebra.

(* Hint Resolve @leq_refl. *)
(* Hint Resolve @plus_assoc @plus_idem @plus_com @plus_neutral_left: algebra. *)
(* Hint Resolve @plus_compat: compat algebra. *)
Hint Rewrite @plus_neutral_left @plus_idem using ti_auto: simpl.  


Ltac fold_leq := match goal with |- equal ?A ?B (?a + ?b) ?b => change (leq A B a b) end.



(** Free, syntactic, model of semilattices, to obtain write reflexive tactics *)
Module U.

  Inductive X :=
  | zero: X
  | plus: X -> X -> X
  | var: positive -> X
    .

  (** Free equality generated by semilattices axioms *)
  Inductive equal: relation X :=
  | refl_zero: equal zero zero
  | refl_var: forall i, equal (var i) (var i)

  | plus_neutral_left: forall x, equal (plus zero x) x
  | plus_idem: forall x, equal (plus x x) x
  | plus_assoc: forall x y z, equal (plus x (plus y z)) (plus (plus x y) z)
  | plus_com: forall x y, equal (plus x y) (plus y x)

  | plus_compat: forall x x', equal x x' -> forall y y', equal y y' -> equal (plus x y) (plus x' y')
  | equal_trans: forall x y z, equal x y -> equal y z -> equal x z
  | equal_sym: forall x y, equal x y -> equal y x  
    .

  Import Positive PositiveUtils.

  Fixpoint collect acc x :=
    match x with
      | plus y z => collect (collect acc y) z
      | zero => acc
      | var i => NumSet.add i acc
    end.

  Definition is_zero x := 
    match x with zero => true | _ => false end.

  Definition f := (fun i acc => if is_zero acc then var i else plus acc (var i)).
  Definition rebuild s := NumSet.fold f s zero.

  (** normalisation function: convert to sets, an back  *)
  Definition norm p := rebuild (collect NumSet.empty p).

  (** decision function *)
  Definition decide x y := NumSet.equal (collect NumSet.empty x) (collect NumSet.empty y).

  (** cleaning function, to remove annihilators  *)
  Fixpoint clean (x: X): X := 
    match x with
      | plus x y => 
        let x := clean x in
          let y := clean y in
            if is_zero x then y
              else if is_zero y then x
                else plus x y
      | x => x
    end.

  
  Lemma Is_zero x: is_zero x = true <-> x = zero.
  Proof.
    destruct x; simpl; intuition discriminate.
  Qed.

  Ltac destruct_if_zero := 
    repeat (
      repeat match goal with
               | H: is_zero ?x = _ |- _ => rewrite H
               | H: is_zero ?x = _, H': context[is_zero ?x] |- _ => rewrite H in H'
             end;
      repeat match goal with 
               | |- context[is_zero ?x] => 
                 match x with 
                   | context[is_zero ?y] => fail 1
                   |  _ => case_eq (is_zero x); let Z := fresh "Z" in intro Z
                 end
             end).

  Ltac replace_zeros :=
    repeat match goal with
             | H: is_zero ?x = true |- _ => rewrite (proj1 (Is_zero x) H) in *; clear H
           end.

  Section correctness.          (* used to protect instances *)
  
    Lemma equal_refl: forall x, equal x x.
    Proof. induction x; constructor; assumption. Qed.
  
    Local Hint Resolve equal_refl plus_neutral_left plus_idem plus_assoc plus_com plus_compat equal_trans: algebra.
    Local Hint Immediate equal_sym: algebra.
  
    Instance equivalence_equal: Equivalence equal.
    Proof. 
      constructor.
       exact equal_refl.
       exact equal_sym.
       exact equal_trans.
    Qed.
    Instance plus_compat_free: Proper (equal ==> equal ==> equal) plus := plus_compat.
  
    Lemma Hc: SetoidList.compat_op eq equal f.
    Proof. 
      intros i j H x y H'. subst. unfold f. 
      case_eq (is_zero x); intro Hx; 
      case_eq (is_zero y); intro Hy. 
      constructor.
      rewrite (proj1 (Is_zero _) Hx) in H'; rewrite <- H'; do 2 constructor.
      rewrite (proj1 (Is_zero _) Hy) in H'; rewrite H'; constructor.
      constructor; trivial; constructor.
    Qed.
      
    Lemma Ht: SetoidList.transpose equal f.
    Proof. 
      intros i j z; unfold f.
      case_eq (is_zero z); intro Hz; simpl. 
      constructor.
      rewrite <- plus_assoc, (plus_com (var j)); constructor.
    Qed.
  
    Lemma collect_correct: forall x q, equal (plus (rebuild q) x) (rebuild (collect q x)).
    Proof.
      induction x; intro q; simpl collect.
       rewrite plus_com. apply plus_neutral_left.
       rewrite plus_assoc, IHx1, IHx2. reflexivity.
       induction q as [|q1 q2 IH z Hz Hq] using NumSetProps.Props.set_induction; unfold rebuild.
        rewrite (NumSetProps.Props.fold_add _ Hc Ht) by NumSetProps.setdec.
        rewrite NumSetProps.Props.fold_1b by assumption.
        apply plus_neutral_left.
  
       destruct (NumSetProps.Props.In_dec p q2) as [Hn|Hn].
        rewrite (NumSetProps.add_fold _ Hc _ Hn).
        rewrite <- (NumSetProps.Props.fold_equal _ Hc Ht _ (NumSetProps.Props.add_remove Hn)).
        rewrite (NumSetProps.Props.fold_add _ Hc Ht) by NumSetProps.setdec.
        unfold f; match goal with |- context[is_zero ?x] => case_eq (is_zero x) end; intro Hx. 
        apply plus_idem.
        rewrite <- plus_assoc, plus_idem; reflexivity.
  
        rewrite (NumSetProps.Props.fold_add _ Hc Ht _ Hn).
        unfold f; match goal with |- context[is_zero ?x] => case_eq (is_zero x) end; intro Hx.
        rewrite (proj1 (Is_zero _) Hx); constructor.
        reflexivity.
    Qed.
  
    (** correctness of the normalisation function  *)
    Lemma normalize: forall x, equal x (norm x).
    Proof.
      intro x. unfold norm. rewrite <- collect_correct.
      symmetry. apply plus_neutral_left.
    Qed.
  
    (** correctness of the decision function  *)
    Theorem decide_correct: forall x y, decide x y = true -> equal x y.
    Proof.
      intros x y H.
      transitivity (norm x); [ apply normalize | ].
      transitivity (norm y); [ | symmetry; apply normalize ].
      apply NumSet.equal_2 in H; unfold norm, rebuild.
  
      rewrite <- (@NumSetProps.Props.fold_equal X equal _ _ Hc Ht _ _ _ H).
      reflexivity.
    Qed.
  
  
    (** preparation for the untyping theorem  *)
    Lemma clean_idem: forall x, clean (clean x) = clean x.
    Proof.
      intro x; induction x; trivial; simpl.
      destruct_if_zero; trivial; simpl.
      rewrite IHx1, IHx2; destruct_if_zero; trivial.
    Qed. 
  
    Lemma equal_clean_zero_equiv : forall x y, equal x y -> is_zero (clean x) = is_zero (clean y).
    Proof.
      intros; induction H; trivial; simpl;
        destruct_if_zero; trivial; discriminate.
    Qed.
  
    Lemma sequal_clean_zero_equiv x y : equal (clean x) (clean y) -> is_zero (clean x) = is_zero (clean y).
    Proof.
      intros; rewrite <- (clean_idem x), <- (clean_idem y).
      apply equal_clean_zero_equiv; assumption.
    Qed.
  
    (** factorisation lemma (for the untyping theorem) *)
    Theorem equal_to_sequal : forall x y, equal x y -> equal (clean x) (clean y).
    Proof.
      intros; induction H; try apply equal_refl; simpl; 
        destruct_if_zero; auto with algebra; 
          solve [
            replace_zeros; auto with algebra 
            |
            repeat match goal with 
                     H: equal (clean ?x) (clean ?y) |- _ => apply sequal_clean_zero_equiv in H
                   end; destruct_if_zero; discriminate 
            |
            eauto 2 with algebra 
          ].
    Qed.

  End correctness.

  

  (** Erasure function, from typed syntax (reified) to the above untyped syntax *)
  Section erase.

    Context `{env: Reification.Env}.
    Import Reification.Semilattice.

    (** erasure function, from typed syntax to untyped syntax *)
    Fixpoint erase n m (x: X n m): U.X :=
      match x with 
        | plus _ _ x y => U.plus (erase x) (erase y)
        | zero _ _ => U.zero
        | var i => U.var i
      end.

  End erase.


  (** Untyping theorem for semilattices, to obtain reflexive typed tactics *)
  Section faithful.

    Import Reification Classes.
    Context `{SL: SemiLattice} {env: Env}.
    Notation feval := Semilattice.eval.

    Inductive eval: forall n m, U.X -> X (typ n) (typ m) -> Prop :=
    | e_zero: forall n m, @eval n m U.zero 0
    | e_plus: forall n m x y x' y', 
                 @eval n m x x' -> @eval n m y y' -> @eval n m (U.plus x y) (x'+y')
    | e_var: forall i, eval (U.var i) (unpack (val i)).
    Implicit Arguments eval [].
    Local Hint Constructors eval.

    (** evaluation of erased terms *)
    Lemma eval_erase_feval: forall n m a, eval n m (erase a) (feval a).
    Proof. induction a; constructor; trivial. Qed.  
  
    (** inversion lemmas about evaluations  *)
    Lemma eval_plus_inv: forall n m x y z, eval n m (U.plus x y) z -> 
      exists x', exists y', z=x'+y' /\ eval n m x x' /\ eval n m y y'.
    Proof. intros. dependent destruction H. eauto. Qed.
  
    Lemma eval_zero_inv: forall n m z, eval n m U.zero z -> z=0. 
    Proof. intros. dependent destruction H. trivial. Qed.
  
    Lemma eval_var_inv: forall n m i z, eval n m (U.var i) z -> z [=] unpack (val i) /\ n=src_p (val i) /\ m=tgt_p (val i).
    Proof. intros. dependent destruction H. intuition reflexivity. Qed.
  
    Ltac eval_inversion :=
      repeat match goal with 
               | H : eval _ _ ?x _ |- _ => eval_inversion_aux H x 
             end
      with eval_inversion_aux H x :=
        let H1 := fresh in 
          match x with 
            | U.zero => pose proof (eval_zero_inv H); subst
            | U.plus _ _ => destruct (eval_plus_inv H) as (?&?&H1&?&?); auto; subst
            | U.var _ => destruct (eval_var_inv H) as (H1&?&?); auto; subst; apply eqd_inj in H1; subst
          end; clear H.
  
    Lemma eval_type_inj_left: forall A A' B x z z', eval A B x z -> eval A' B x z' -> A=A' \/ is_zero (clean x) = true.
    Proof.
      intros A A' B x z z' H; revert A' z'; induction H; intros A' z' H';
        eval_inversion; auto. 
 
      destruct (IHeval2 _ _ H3) as [|Hx]; auto.
      destruct (IHeval1 _ _ H2) as [|Hy]; auto.
      right; simpl. rewrite Hy. assumption.
    Qed.
    
    Lemma eval_clean_zero: forall x, is_zero (clean x) = true -> forall A B z, eval A B x z -> z==0.
    Proof.
      induction x; simpl; intros H A B z Hz; try discriminate; eval_inversion.
      reflexivity.
  
      case_eq (is_zero (clean x1)); intro Z1; rewrite Z1 in H.
      rewrite (IHx2 H _ _ _ H2), (IHx1 Z1 _ _ _ H1); apply plus_idem.
  
      case_eq (is_zero (clean x2)); intro Z2; rewrite Z2 in H.
      rewrite H in Z1; discriminate.
      discriminate.
    Qed.
  
    Lemma eval_clean: forall A B x y, eval A B x y -> exists2 z, eval A B (clean x) z & y==z.
    Proof.
      intros A B x y H; induction H; simpl.
  
      exists 0; auto.
  
      destruct_if_zero.
       destruct IHeval2 as [y'' Hy'' Hy]; exists y''; auto.
       rewrite (eval_clean_zero Z H), Hy; apply plus_neutral_left.
  
       destruct IHeval1 as [x'' Hx'' Hx]; exists x''; auto.
       rewrite (eval_clean_zero Z0 H0), Hx; rewrite plus_com; auto with algebra.
  
       destruct IHeval1; destruct IHeval2; eauto with compat.
             
      eexists; auto.
    Qed.
  
    Lemma eval_inj: forall A B x y z, eval A B x y -> eval A B x z -> y=z.
    Proof.
      intros A B x y z H; revert z; induction H; intros; eval_inversion; try reflexivity.
      rewrite (IHeval1 _ H3), (IHeval2 _ H4); reflexivity.
    Qed.
  
  
    Lemma and_idem: forall (A: Prop), A -> A/\A.
    Proof. auto. Qed.
  
    Ltac split_IHeval :=
      repeat match goal with 
               | H: (forall A B x', eval A B ?x x' -> _) /\ _ ,
                 Hx: eval ?A ?B ?x ?x' |- _ => destruct (proj1 H _ _ _ Hx); clear H
               | H: _ /\ forall A B x', eval A B ?x x' -> _  ,
                 Hx: eval ?A ?B ?x ?x' |- _ => destruct (proj2 H _ _ _ Hx); clear H
             end;
      repeat match goal with 
               | H: (forall A B x', eval A B ?x x' -> _) 
                 /\ (forall A B y', eval A B ?y y' -> _) |- _ => destruct H
             end.
  
    Lemma eval_equal_aux: forall x y, U.equal x y -> forall A B x', eval A B x x' -> exists2 y', eval A B y y' & x'==y'.
    Proof.
      intros x y H.
      cut ((forall A B x', eval A B x x' -> exists2 y', eval A B y y' & x'==y')
              /\ (forall A B y', eval A B y y' -> exists2 x', eval A B x x' & y'==x')); [tauto| ].
      induction H; (apply and_idem || split); intros A B xe Hx; 
        eval_inversion; split_IHeval;
        eauto with algebra; eauto 3 using Graph.equal_trans.
  
      eexists; eauto.
      rewrite (eval_inj H0 H1); apply plus_idem.
    Qed.
    
    (** untyping theorem  *)
    Theorem equal_eval: forall x' y', U.equal x' y'-> forall A B x y, eval A B x' x -> eval A B y' y -> x==y.
    Proof.
      intros x' y' H A B x y Hx Hy.
      destruct (eval_clean Hx) as [x1 Hx1 Hx1'].
      destruct (eval_clean Hy) as [y1 Hy1 Hy1'].
      destruct (eval_equal_aux (equal_to_sequal H) Hx1) as [y2 Hy2 Hy2'].
      rewrite Hx1', Hy1', Hy2'.
      rewrite (eval_inj Hy2 Hy1).
      reflexivity.
    Qed.

    (* other formulation, using the intermediate reification syntax *)
    Theorem erase_faithful: forall n m (a b: Semilattice.X n m), 
      U.equal (erase a) (erase b) -> feval a == feval b.
    Proof. intros. eapply equal_eval; eauto using eval_erase_feval. Qed.

    (* combination with the untyped decision procedure, to get the reflexive tactic *)
    Lemma decide_typed: forall n m (a b: Semilattice.X n m), 
      decide (erase a) (erase b) = true -> feval a == feval b.
    Proof. intros. apply erase_faithful, decide_correct. assumption. Qed.

    (* for the aci_normalize tactic *)
    Lemma normalizer {n} {m} {R} `{T: Transitive (Classes.X (typ n) (typ m)) R} `{H: subrelation _ (equal _ _) R} : 
      forall a b: Semilattice.X n m, 
        (let na := norm (erase a) in
          let nb := norm (erase b) in
            exists a', erase a' = na /\
              exists b', erase b' = nb /\
                R (feval a') (feval b')) ->
        R (feval a) (feval b).
    Proof.
      intros a b; intros [a'[Ha[b'[Hb Hab]]]].
      assert (Ha': feval a == feval a').
       apply erase_faithful. rewrite Ha. apply normalize.
      assert (Hb': feval b == feval b').
       apply erase_faithful. rewrite Hb. apply normalize.
      rewrite Ha'. rewrite Hab. apply H. symmetry. apply Hb'.
    Qed.

  End faithful.
  Implicit Arguments normalizer [[G] [SLo] [SL] [env] [n] [m] [R] [T] [H] a b].

End U.


(** the two reflexive tactics for semilattices  *)
Ltac aci_reflexivity := 
  unfold leq;
  semilattice_reify; intros;
  apply U.decide_typed; vm_compute; 
    (reflexivity || fail "Not an ACI theorem").

Ltac aci_normalize :=
  let get_types tac := 
    lazymatch goal with 
      | |- @equal _ (@Reification.typ _ _ ?A) (@Reification.typ _ _ ?B) _ _ => tac A B
      | |- @leq ?G _ (@Reification.typ _ _ ?A) (@Reification.typ _ _ ?B) _ _ => tac A B
      | _ => fail 1 "Not an (in)equality"
    end in
  let t := fresh "t" in
  let e := fresh "e" in
  let l := fresh "l" in
  let r := fresh "r" in
  let x := fresh "x" in
  let y := fresh "y" in
  let run A B :=
    let rebuild e x :=
      let rec build x := 
        match x with 
          | U.plus ?x ?y => let x := build x in let y := build y in constr:(Reification.Semilattice.plus x y)
          | U.zero => constr:(Reification.Semilattice.zero A B) 
          | U.var ?i => constr:(Reification.Semilattice.var i)
        end
      in 
        match eval unfold x in x with ?x => match build x with ?x => exists x end end;
        split; [reflexivity|]
    in
        apply U.normalizer;
          intros x y; vm_compute in x, y;
            rebuild e x; rebuild e y; 
            compute [t e l r Reification.Semilattice.eval Reification.unpack 
              Reification.val Reification.typ Reification.tgt Reification.src
              Reification.tgt_p Reification.src_p
              Reification.sigma_get Reification.sigma_add Reification.sigma_empty 
              FMapPositive.PositiveMap.find FMapPositive.PositiveMap.add 
              FMapPositive.PositiveMap.empty ];
              clear t e x y l r
  in 
    semilattice_reify; intros t e l r;
    get_types run.  
  
(*begintests
Section tests.
  (* tests pour les tactiques précédentes *)
  Goal forall `{SemiLattice} A B (a b c: X A B), c+a+(b+c+0)+a == c+(a+0+(0+b)+(c+a)).
    intros.
    aci_reflexivity.
  Qed.
  
  Goal forall `{SemiLattice} A B (a b c: X A B), c+a+0+a <== c+(a+0+(0+b)+(c+a)).
    intros.
    aci_reflexivity.
  Qed.
  
  Goal forall `{SemiLattice} A B (a b c: X A B), c+a+(b+c+0)+a == c+(a+0+(0+b)+(c+a)).
    intros.
    aci_normalize.
    reflexivity.
  Qed.
  
  Goal forall `{IdemSemiRing} A (a b c: X A A), c+a*b+(b+c+0)+a <== c+(a+0+(0+b)+(c+a*b)).
    intros.
    aci_normalize.
    reflexivity.
  Qed.
  
  Goal forall `{KleeneAlgebra} A (a b c: X A A), c+a*b+(b#+c+0)+a <== c+(a+0+(0+b#)+(c+a*b)).
    intros.
    aci_reflexivity.
  Qed.
  
  Goal forall `{KleeneAlgebra} A (a b c: X A A), c+a*b+(b#+c+0)+a == c+(a+0+(0+b#)+(c+a*b)).
    intros.
    aci_normalize.
    reflexivity.
  Qed.
End tests
endtests*)



(** simple tactic for closed rewriting modulo AC, in Ltac *)
Lemma switch `{SemiLattice} A B (a b c : X A B) : (a+b)+c == (a+c)+b.
Proof. intros. aci_reflexivity. Qed.
    
Ltac peigne a b n :=
  match goal with 
    | |- context [?q + b] => 
      match q with 
        | context [a] => ( peigne_aux (q+b) a b  (* || idtac "fail 1" q b a b *) ) ; (try set (n := a+b))
      end
    | |- context [?q + a] =>
      match q with 
        | context [b] => ( peigne_aux (q+a) b a  (* || idtac "fail 2" *) ) ; try (rewrite (plus_com b a); set (n := a+b))
      end
    | _ => fail 0 "failed to find " a " and " b " in the goal"
  end
with 
  peigne_aux q a b :=
  match q with 
    | (?q'+a)+b => rewrite <- (plus_assoc q' a b)
    | (?q'+?x)+b => rewrite (switch q' x b); peigne_aux (q' +b) a b   
    | a+b => idtac 
    | ?q' + ?x => peigne_aux q' a b 
    | ?x => fail x   end.

Ltac atomic a :=
  match a with | _ + _ => fail 1 | _ => idtac  end.
Ltac agglomere_motif pat n :=
  match pat with 
    | ?pat' + ?a => atomic a; 
      let x := fresh "pat" in 
        let x' := fresh "pat_plus_a" in 
          (agglomere_motif pat' x;
            peigne x a x';
            subst x; set (n := x'); subst x')
    | ?a => atomic a; set (n := a)
    | _ => fail 0 "failed to find the term: " pat 
  end.

Ltac ac_rewrite Li := 
  lazymatch type of Li with 
    | ?pat == _ => 
      (let n := fresh "ac_rewrite" in agglomere_motif pat n; 
        subst n; rewrite Li
      ) || fail "failed to gather the pattern."
    | ?pat <== _ => 
      (let n := fresh "ac_rewrite" in agglomere_motif pat n; 
        subst n; rewrite Li
      ) || fail "failed to gather the pattern."
    | ?x => fail "Not an (in)equality: " Li ": " x
  end.


(*begintests
Section test_ac_rewrite.
  Context `{ISR: IdemSemiRing}.
  Variable A B : T.
  Variable a b c d e f g: X A B.

  Hypothesis H  : a + b + c+d+e == d.
  Hypothesis H'  : a + b + c+d+e == d.

  Goal a + b + c + d == d.
    peigne a c toto.
    rewrite switch.
  Abort.
  
  Goal a + b + c + d == d. 
    agglomere_motif (a+c+d) toto.
  Abort. 
  
  Goal e + d + a + b  +c <== d.
    ac_rewrite H.
    reflexivity.
  Qed.

  Goal e + d + a + b + e +c <== e+d.
    ac_rewrite H'.
    reflexivity.
  Qed.

  Hypothesis J :  f + g == c.
  Goal e + d + a + b + e + f + g == d.
    aci_normalize.
    ac_rewrite J.
    aci_normalize.
    ac_rewrite H.
    aci_reflexivity.
  Qed.

  Variable C : T.
  Variable h : X B C.
  Goal (f+g)*h + 1*f*h == 1*c*h +1*f*1*h*1.
    ac_rewrite J.
    rewrite !dot_neutral_left, !dot_neutral_right.
    aci_reflexivity.
  Qed.

  Variable i j : X C C.
  Goal (f+g)*h*i*j + (a+b+f+d+g+e)* h *i == c*h*i*j + d*h*i.
    ac_rewrite J.
    ac_rewrite J.
    ac_rewrite H.
    reflexivity.
  Qed.
End test_ac_rewrite.  
endtests*)


(** finite sums and their properties  *)
Section FSumDef.

  Context `{SL: SemiLattice}.

  Variables A B: T.
  
  (* sum i..i+k-1 *)
  Fixpoint sum i k (f: nat -> X A B): X A B :=
    match k in nat return X A B with
      | 0 => 0
      | S k => f i + sum (S i) k f
    end.

  Lemma sum_empty i (f: nat -> X A B): sum i 0 f == 0.
  Proof. reflexivity. Qed.

  Lemma sum_enter_left i k (f: nat -> X A B):
    sum i (S k) f == f i + sum (S i) k f.
  Proof. reflexivity. Qed.

  Lemma sum_enter_right i k (f: nat -> X A B):
    sum i (S k) f == sum i k f + f (i+k)%nat.
  Proof. 
    revert i; induction k; intro i.
    simpl. rewrite plus_0_r; apply plus_com.
    change (sum i (S (S k)) f) with (f i + sum (S i) (S k) f).
    rewrite IHk, plus_assoc. simpl. auto with compat.
  Qed.

End FSumDef.
Opaque sum.
Ltac simpl_sum_r := simpl; repeat setoid_rewrite sum_empty; repeat setoid_rewrite sum_enter_right.
Ltac simpl_sum_l := simpl; repeat setoid_rewrite sum_empty; repeat setoid_rewrite sum_enter_left.



(** various properties of semilattices and finite sums  *)
Section Props1.

  Context `{SL: SemiLattice}.
  Variables A B: T.

  Lemma plus_neutral_right: forall (x: X A B), x+0 == x.
  Proof. intros; aci_reflexivity. (* rewrite plus_com; apply plus_neutral_left. *) Qed.
  
  Lemma zero_inf: forall (x: X A B), 0 <== x.
  Proof (@plus_neutral_left _ _ _ A B).  
  
  Lemma plus_make_left: forall (x y: X A B), x <== x+y.
  Proof. intros; aci_reflexivity. (* unfold leq; rewrite plus_assoc, plus_idem; reflexivity. *) Qed.
  
  Lemma plus_make_right: forall (x y: X A B), x <== y+x.
  Proof. intros; aci_reflexivity. (* unfold leq; rewrite (plus_com y); apply plus_make_left. *) Qed.
  
  Lemma plus_destruct_leq: forall (x y z : X A B), x<==z -> y<==z -> x+y<==z.
  Proof. unfold leq; intros x y z H H'; ac_rewrite H'; trivial. Qed. 

  Lemma leq_destruct_plus: forall (x y z: X A B), x+y <== z -> x<==z /\ y<==z.
  Proof. intros x y z H; rewrite <- H; split; aci_reflexivity. Qed.
    

  Global Instance plus_incr:
  Proper ((leq A B) ==> (leq A B) ==> (leq A B)) (plus A B).
  Proof. 
    unfold leq; intros x x' Hx y y' Hy.
    rewrite <- Hy at 2; rewrite <- Hx at 2.
    aci_reflexivity.
  Qed.

  Lemma sup_def: forall (x y: X A B), (forall z, x <== z <-> y <== z) -> x==y.
  Proof.
    intros x y H. apply leq_antisym.
    apply <- H; reflexivity.
    apply -> H; reflexivity.
  Qed.

  Lemma inf_def: forall (x y: X A B), (forall z, z <== x <-> z <== y) -> x==y.
  Proof.
    intros x y H. apply leq_antisym.
    apply -> H; reflexivity.
    apply <- H; reflexivity.
  Qed.

  Lemma sum_compat (f f':nat -> X A B) i k:
    (forall n, n<k -> f (i+n)%nat == f' (i+n)%nat) -> sum i k f == sum i k f'.
  Proof.
    induction k; intro E; simpl_sum_r.
    reflexivity.
    rewrite IHk, E by auto with arith.
    reflexivity.
  Qed.

  Global Instance sum_compat' i k: 
  Proper ((pointwise_relation nat (equal A B)) ==> (equal A B)) (sum i k).
  Proof. repeat intro; auto using sum_compat. Qed.
   
  Lemma sum_zero i k (f: nat -> X A B):
    (forall n, n<k -> f (i+n)%nat == 0) -> sum i k f == 0.
  Proof.
    induction k; intro E; simpl_sum_r.
    reflexivity.
    rewrite IHk, E by auto with arith.  
    apply plus_idem.
  Qed.
  
  Lemma sum_fun_zero i k : 
    sum i k (fun _ =>(0 : X A B)) == 0.
  Proof.
    rewrite sum_zero; auto. 
  Qed.
  
  Lemma sum_cut k' i k (f: nat -> X A B):
    sum i (k'+k) f == sum i k f + sum (k+i) k' f.
  Proof.
    induction k'; simpl_sum_r.
    aci_reflexivity.
    rewrite IHk', plus_assoc.
    auto with compat omega.
  Qed.
  
  Lemma sum_cut_fun i k (f g: nat -> X A B):
    sum i k (fun u => f u + g u) == sum i k f + sum i k g.
  Proof.
    induction k; simpl_sum_r.
    aci_reflexivity.
    rewrite IHk.
    aci_reflexivity.  
  Qed.
    
  Lemma sum_cut_nth n (f: nat -> X A B) i k:
    n<k -> sum i k f == sum i n f + f (i+n)%nat + sum (i+S n) (k-n-1) f.
  Proof.
    intros; pattern k at 1; replace k with (S(k-n-1)+n)%nat by omega. 
    rewrite sum_cut.
    rewrite sum_enter_left, plus_assoc.
    auto with compat omega.
  Qed.
  Implicit Arguments sum_cut_nth [].
  
  Lemma sum_shift d (f: nat -> X A B) i k:
    sum (i+d) k f == sum i k (fun u => f (u+d)%nat).
  Proof.
    induction k; simpl_sum_r; auto with compat omega.
  Qed.
    
  Theorem sum_inversion (f: nat -> nat -> X A B) i i' k k':
       sum i k (fun u => (sum i' k' (f u)))
    == sum i' k' (fun u'=> (sum i k (fun u => f u u'))).
  Proof.
    induction k'; simpl_sum_r.
    apply sum_zero; reflexivity. 
    rewrite sum_cut_fun.
    rewrite IHk'; reflexivity.
  Qed.
  
  Lemma leq_sum (f: nat -> X A B) i k x:
    (exists n, i<=n /\ n<i+k /\ x <== f n) -> x <== sum i k f.
  Proof. 
    intros [n [? [? E]]].
    rewrite E, (sum_cut_nth (n-i))  by omega. 
    replace (i+(n-i))%nat with n by auto with arith. 
    aci_reflexivity. 
  Qed.

  Lemma sum_leq (f : nat -> X A B) i k x: 
    (forall n, i <= n -> n < i +k -> f n <== x) -> sum i k f <== x.
  Proof.
    revert x.
    induction k. 
    intros x H. simpl_sum_r. apply plus_neutral_left.
    intros x H. simpl_sum_r. rewrite (IHk x) , H. aci_reflexivity. 
    auto with arith.
    auto with arith.
    intros; apply H; omega.  
  Qed.
    
  Lemma sum_plus : forall (f : nat -> X A B) i k a, 0 < k -> sum i k f + a == sum i k (fun n => f n + a).
  Proof.
    induction k; intros.
      omega_false.
      simpl_sum_r.
      destruct (eq_nat_dec 0 k).
        subst. simpl_sum_r. aci_reflexivity.   
        setoid_rewrite <- IHk. aci_reflexivity.
        omega.
  Qed.
    
  Lemma sum_constant : forall i k (a : X A B),  0 < k -> sum i k (fun _ => a) == a.
  Proof. 
    induction k; intros. 
      omega_false.
      simpl_sum_r.   
      destruct (eq_nat_dec 0 k).
        subst. simpl_sum_r. aci_reflexivity.   
        setoid_rewrite IHk. aci_reflexivity.
        omega.
  Qed.

  Lemma sum_collapse n (f: nat -> X A B) i k:
    n<k ->
    (forall x,  x <> (i+n)%nat -> f x == 0) ->
    sum i k f == f (i+n)%nat.
  Proof.
    intros Hn H.
    rewrite (sum_cut_nth n), 2 sum_zero by  ( auto || intros; apply H ; omega).
    aci_reflexivity.
  Qed.    

  Lemma sum_incr (f f': nat -> X A B) i k:
    (forall n, n<k -> f (i+n)%nat <== f' (i+n)%nat) -> sum i k f <== sum i k f'.
  Proof.
    induction k; intro E; simpl_sum_r.
    reflexivity.
    rewrite 2 sum_enter_right.
    rewrite IHk, E by auto with arith.
    reflexivity.
  Qed.
    
  Global Instance sum_incr' i k: 
  Proper ((pointwise_relation nat (leq A B)) ==> (leq A B)) (sum i k).
  Proof. repeat intro; auto using sum_incr. Qed.


  Lemma xif_plus: forall b (x y z: X A B), xif b x y + z == xif b (x+z) (y+z).
  Proof. intros. destruct b; trivial. Qed.

  Lemma plus_xif: forall b (x y z: X A B), z + xif b x y == xif b (z+x) (z+y).
  Proof. intros. destruct b; trivial. Qed.


  (* rather specific lemmas, used in the proof of DKA *)
  Lemma xif_sum_zero: forall b i k (f: nat -> X A B), xif b (sum i k f) 0 == sum i k (fun j => xif b (f j) 0).
  Proof.
    intros. revert i. induction k; intro i; simpl_sum_l. 
     apply xif_idem.
     rewrite <- IHk. destruct b; auto with algebra.
  Qed.

  Lemma sum_fixed_xif_zero: forall v k b (x: X A B), v < k -> b v = true -> sum 0 k (fun u => xif (b u) x 0) == x.
  Proof.
    intros v k b x ? H. apply leq_antisym.
    apply sum_leq. intros. case b. apply leq_refl. apply zero_inf.
    apply leq_sum. exists v. rewrite H. auto with arith. 
  Qed.

  Lemma compare_sum_xif_zero: forall k k' b c (x: X A B), 
    (forall i, i < k -> b i = true -> exists2 j, j < k' & c j = true) ->
    sum 0 k (fun i => xif (b i) x 0) <== sum 0 k' (fun j => xif (c j) x 0).
  Proof.
    intros until x; intro H. apply sum_leq. intros n _ Hn.
    specialize (H _ Hn). destruct (b n). destruct (H refl_equal) as [j ? Hj].
    apply leq_sum. exists j. rewrite Hj. auto with arith.
    apply zero_inf.
  Qed.


End Props1.
Implicit Arguments sum_cut_nth [[G] [SLo] [SL] A B].



(*begintests
Section tests_rewrite.
  Goal forall `{KleeneAlgebra} A (x y z: X A A), x+y == y+x+x -> (x+y)+z <== x#.
    intros.
    rewrite H0.
  Abort.
  Goal forall `{KleeneAlgebra} A (x y z: X A A), x+y == y+x+x -> (x+y)+z <== x#+(x+y).
    intros.
    rewrite H0 at 1.
    rewrite H0.
  Abort.
  Goal forall `{KleeneAlgebra} A (x y z: X A A), x+y <== y+x+x -> (x+y)+z <== x#.
    intros.
    rewrite H0.
  Abort.
  
  Goal forall `{KleeneAlgebra} A (x y z: X A A), x+y==z# -> sum 6 8 (fun _ => (x+y)+z) == z.
    intros.
    setoid_rewrite H0.
  Abort.
  
  Goal forall `{KleeneAlgebra} A (x y z: X A A), x+y==z# -> sum 6 8 (fun _ => (x+y)+z) <== z.
    intros.
    setoid_rewrite H0.
  Abort.
  
  Goal forall `{IdemSemiRing} A (x y z: X A A), x+y<==z*z -> sum 6 8 (fun _ => (x+y)+z) <== z.
    intros.
    setoid_rewrite H0.
  Abort.
End tests_rewrite.
endtests*)


(** Hints  *)

Hint Extern 0 (equal _ _ _ _) => first [ 
  apply plus_neutral_right 
]: algebra.
Hint Extern 1 (equal _ _ _ _) => first [ 
    apply sum_compat
]: compat algebra.

Hint Extern 0 (leq _ _ _ _) => first [ 
  apply plus_destruct_leq
  | apply plus_make_left
  | apply plus_make_right
  | apply zero_inf
]: algebra.
Hint Extern 1 (leq _ _ _ _) => first [ 
    apply sum_incr
]: compat algebra.
Hint Extern 2 (leq _ _ _ _) => first [ 
    apply plus_incr
]: compat algebra.

(* Hint Resolve @sum_compat @sum_incr @plus_incr: compat algebra. *)
(* Hint Resolve  *)
(*   @plus_destruct_leq @plus_make_left @plus_make_right  *)
(*   @zero_inf @plus_neutral_right *)
(*   : algebra. *)
Hint Rewrite @plus_neutral_right using ti_auto: simpl.  

